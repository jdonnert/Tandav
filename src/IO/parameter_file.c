#include "parameter_file.h"

#define NTAGS 8096

struct Parameters_From_File Param = { 0 }; 

void sanity_check_input_parameters();

void IO_Read_Parameter_File(const char *filename)
{
	char buf[CHARBUFSIZE] = { "" },
		 buf1[CHARBUFSIZE]= { "" },
		 buf2[CHARBUFSIZE]= { "" },
		 buf3[CHARBUFSIZE]= { "" };

	bool tagDone[NTAGS] = { false };

	if (Task.Is_Master) {

		FILE *fd = fopen(filename, "r");

		Assert(fd != NULL, "Parameter file not found %s \n", filename);

		printf("\nReading Parameter file '%s' \n", filename);

		while (fgets(buf, CHARBUFSIZE, fd)) {

			sscanf(buf, "%s %s %s", buf1, buf2,buf3) ;

			if (buf1[0] == '%') // commented out
				continue;

			int j = -1;

			for (int i = 0; i < NTags; i++) {

				int tagNotFound = strcmp(buf1, ParDef[i].tag);

				if (!tagNotFound && !tagDone[i]) {

					j = i;

					tagDone[i] = true;

					break;
				}
			}

			if (j < 0) // I don't know this one, skip
				continue;

			printf(" %20s  %s\n", buf1, buf2);

			switch (ParDef[j].type) {

			case PAR_COMMENT:
				break;

			case PAR_DOUBLE:

				*((double *)ParDef[j].addr) = atof(buf2);

				break;

			case PAR_STRING:

				strncpy((char *)ParDef[j].addr, buf2, CHARBUFSIZE); 

				break;

			case PAR_INT:

				*((int *)ParDef[j].addr) = atoi(buf2);

				break;

			default:
				Assert(false,"Code Error in ParDef struct: %s", ParDef[j].tag);
			}
		}

		fclose(fd);

		printf("\nAssuming: \n");

		for (int i = 0; i < NTags; i++) { // are we missing one ?
			
			if (tagDone[i] || ParDef[i].type == PAR_COMMENT) 
				continue;

			printf(" %20s  %s \n", ParDef[i].tag, ParDef[i].val);

			switch (ParDef[i].type) {

			case PAR_COMMENT:
				break;

			case PAR_DOUBLE:

				*((double *)ParDef[i].addr) = atof(ParDef[i].val);

				break;

			case PAR_STRING:

				strncpy((char *)ParDef[i].addr, ParDef[i].val, CHARBUFSIZE); 

				break;

			case PAR_INT:

				*((int *)ParDef[i].addr) = atoi(ParDef[i].val);

				break;

			default:
				Assert(false,"Code Error in ParDef struct: %s", ParDef[i].tag);
			}
		}
		
		printf("\n");

		sanity_check_input_parameters();
	}

	MPI_Bcast(&Param, sizeof(Param), MPI_BYTE, MASTER, MPI_COMM_WORLD);

	return ;
}

void IO_Write_Parameter_File(const char *filename)
{
	if (Task.Is_Master) {

		printf("\nWriting Parameter file: %s \n", filename);

		FILE *fd = fopen(filename, "w");

		Assert(fd != NULL, "Can't open file %s for writing \n", filename);

		fprintf(fd, "%% Tandav, autogenerated parameter file %% \n\n");

		for (int i = 0; i < NTags; i++) {

			fprintf(fd, "%s", ParDef[i].tag);

			if (ParDef[i].type != PAR_COMMENT)
				fprintf(fd, "		%s \n", ParDef[i].val);
		}

		fclose(fd);

		printf("\ndone, Good Bye.\n\n");
	}

	MPI_Barrier(MPI_COMM_WORLD);

	return ; // never reached
}

void sanity_check_input_parameters()
{
	Assert(Param.Num_Output_Files > 0, "NumOutputFiles has to be > 0");

	Assert(Param.Num_IO_Tasks > 0, "NumIOTasks has to be > 0");

	Warn(Param.Buffer_Size > Param.Max_Mem_Size / 10.0,
			"BufferSize (%d MB) should be much smaller than MaxMemSize (%d MB)",
			Param.Buffer_Size,  Param.Max_Mem_Size);

	Warn((double)Param.Buffer_Size * p2(1024.0)/sizeof_P < 1000.0,
		"Thread Safe buffer holds less than 1024 particles "
		"Task.Buffer_Size > %d MB recommended, have %g"
		, 10000*sizeof_P/1024/1024 , Param.Buffer_Size/1024.0/1024.0);

	Warn(Param.Num_IO_Tasks > NRank,
		"NRank (=%d) can't be smaller than No_IOTasks (=%d), resetting ...",
		NRank,  Param.Num_Output_Files);

	Warn(Param.Num_IO_Tasks > Param.Num_Output_Files,
		"Num_IO_Tasks (=%d) can't be larger than Num_Output_Files (=%d)",
		Param.Num_IO_Tasks,  Param.Num_Output_Files);

	Param.Num_IO_Tasks = MIN(Param.Num_IO_Tasks, NRank);

	Param.Num_Output_Files = MIN(Param.Num_Output_Files, NRank);

	Assert(Time.First_Snap >= Time.Begin, "TimeBegin > TimeOfFirstSnaphot !!");

#ifdef COMOVING
	Assert(Time.Begin > 0, "TimeBegin > 0 required for COMOVING, have %g ", 
			Time.Begin); 
	
	Warn(Time.Begin > 1, "Simulation starts in the future !");
#endif

	/* Add here ! */

	return ;
}

// Copyright (C) 2013 Julius Donnert (donnert@ira.inaf.it)
